<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Log Monitor</title>
<style>
  body {
    font-family: "Courier New", monospace;
    background: #1e1e2f;
    color: #eee;
    margin: 0;
    padding: 20px;
  }

  h3 {
    text-align: center;
    color: #f5f5f5;
  }

  #controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  textarea, input[type=text] {
    font-family: monospace;
    padding: 8px;
    border-radius: 5px;
    border: 1px solid #555;
    background: #2b2b3f;
    color: #eee;
  }

  textarea {
    flex: 1 1 300px;
    height: 80px;
  }

  button {
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    background: #4e9af1;
    color: #fff;
    cursor: pointer;
  }

  button:hover {
    background: #3378d7;
  }

  #panels-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
  }

  .log-panel {
    min-width: 0; /* allow shrinking */
    height: 600px;
    min-height: 300px;
    resize: vertical;
    overflow: hidden;
  }

  #panels-container > .log-panel:last-child:nth-child(odd) {
    grid-column: span 2;
  }

  .log-panel-header {
    font-weight: bold;
    color: #48dbfb;
    margin-bottom: 8px;
  }

  .panel-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-bottom: 8px;
  }

  .logs-container {
    display: flex;
    flex-direction: column;
    flex: 1;
    gap: 6px;
    overflow: hidden;
  }

  .search-results {
    background: #111;
    border-radius: 5px;
    padding: 6px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    margin-top: 8px;
    min-height: 40px;
    max-height: 120px;
    overflow-y: auto;
  }

  .panel-bottom {
    background: #23233a;
    border-radius: 5px;
    margin-top: 8px;
    margin-bottom: 16px;
    padding: 8px;
    flex: 0 0 auto;
    max-height: 200px;
    min-height: 40px;
    overflow-y: auto;
}

  .panel-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 8px;
  }

  .panel-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .panel-content {
    display: flex;
    flex-direction: column;
    flex: 1 1 auto;
    min-height: 0;
    height: 100%;
  }

  .tail-logs {
    background: #1a1a2e;
    border-radius: 5px;
    padding: 6px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    flex: 1 1 auto;
    min-height: 100px;
    max-height: none;
    overflow-y: auto;
    overflow-x: auto;
    white-space: pre;
  }

  .search-results {
    flex: none;
    background: #111;
  }

  .match {
    background-color: rgba(255, 215, 0, 0.25);
    font-weight: bold;
  }

  .match-current {
    background-color: rgba(255, 99, 71, 0.5);
  }

  .resume-scroll {
    margin-top: 5px;
    align-self: flex-start;
    background: #f39c12;
    display: none;
  }
</style>
</head>
<body>
<h3>LoggyXP</h3>

<div id="controls">
  <textarea id="paths" placeholder="Enter log paths, one per line"></textarea>
  <button id="add-path">Add Path(s)</button>
  <button id="stop-all">Stop All</button>
</div>

<div id="panels-container"></div>

<script>
const ws = new WebSocket("ws://localhost:3000/ws");
const panelsContainer = document.getElementById("panels-container");
const pathInput = document.getElementById("paths");
const panels = new Map();
const SCROLL_DELTA = 1;

// Send command to backend
function sendCommand(type, paths, extra = {}) {
  ws.send(JSON.stringify({ type, paths, ...extra }));
}

// Global WebSocket handler
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  const panel = panels.get(msg.path);
  if (!panel) return;

  if (msg.type === "log") {
    const tailEl = panel.tailEl;
    const panelDiv = panel.panelDiv;
    const div = document.createElement("div");
    div.textContent = msg.line;
    tailEl.appendChild(div);

    // Smart auto-scroll inside tail
    const { scrollTop, scrollHeight, clientHeight } = tailEl;
    const autoScroll = scrollTop + clientHeight >= scrollHeight - SCROLL_DELTA;
    if (autoScroll) {
      tailEl.scrollTop = tailEl.scrollHeight;

      // Scroll panel into view so newest lines are visible
      panelDiv.scrollIntoView({ behavior: "smooth", block: "end" });
    }
  }

  if (msg.type === "search_result") {
  const searchEl = panel.searchEl;
  const hasNormal = msg.lines.some(line => !line.includes("NOTIFICATION:"));
  if (hasNormal) searchEl.innerHTML = "";
  msg.lines.forEach(line => {
      const div = document.createElement("div");
      div.textContent = line;
      if (line.includes("NOTIFICATION:")) {
        div.classList.add("match-current");
      } else {
        searchEl.innerHTML = ""; // clear for normal search
        div.classList.add("match");
      }
    });
  } 
};

// Create a new log panel
function createPanel(path) {
  if (panels.has(path)) return;

  const panelDiv = document.createElement("div");
  panelDiv.className = "log-panel";
panelDiv.innerHTML = `
  <div class="log-panel-header">${path}</div>
  <div class="panel-content">
    <div class="panel-controls" style="flex-direction:column;align-items:flex-start;">
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:6px;">
        <button class="start">Start</button>
        <button class="stop">Stop</button>
        <button class="clear">Clear</button>
        <button class="remove">Remove</button>
        <input type="text" class="pattern" placeholder="Search pattern" />
        <label><input type="checkbox" class="search-regex" /> Regex</label>
        <button class="search">Search</button>
        <button class="clear-search">Clear Search</button>
      </div>
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:6px;">
        <input type="text" class="panel-filter" placeholder="Filter lines (substring)" />
        <button class="apply-filter">Apply Filter</button>
        <button class="clear-filter">Clear Filter</button>
        <span style="display:inline-block; width:24px;"></span>
        <input type="text" class="panel-notify" placeholder="Notify when (substring)" />
        <button class="apply-notify">Set Notification</button>
        <button class="clear-notify">Clear Notification</button>
      </div>
    </div>
    <div class="logs-container">
      <div class="tail-logs"></div>
      <button class="resume-scroll">Resume Auto-Scroll</button>
    </div>
    <div class="panel-bottom">
      <div class="search-results"></div>
    </div>
  </div>
`;

  panelsContainer.appendChild(panelDiv);

  const tailEl = panelDiv.querySelector(".tail-logs");
  const searchEl = panelDiv.querySelector(".search-results");
  const patternInput = panelDiv.querySelector(".pattern");
  const regexInput = panelDiv.querySelector(".search-regex");
  const searchBtn = panelDiv.querySelector(".search");
  const filterInput = panelDiv.querySelector(".panel-filter");
  const filterCheckbox = panelDiv.querySelector(".filter-checkbox");
  const applyFilterBtn = panelDiv.querySelector(".apply-filter");
  const notifyInput = panelDiv.querySelector(".panel-notify");
  const notifyCheckbox = panelDiv.querySelector(".notify-checkbox");
  const applyNotifyBtn = panelDiv.querySelector(".apply-notify");
  const clearSearchBtn = panelDiv.querySelector(".clear-search");
  const clearFilterBtn = panelDiv.querySelector(".clear-filter");
  const clearNotifyBtn = panelDiv.querySelector(".clear-notify");




  let autoScroll = true;
  panelDiv.filterValue = "";
  panelDiv.notifyValue = "";

  const resumeBtn = panelDiv.querySelector(".resume-scroll");

  tailEl.addEventListener("scroll", () => {
    const { scrollTop, scrollHeight, clientHeight } = tailEl;
    // If user is NOT at the bottom, pause auto-scroll
    if (scrollTop + clientHeight < scrollHeight - SCROLL_DELTA) {
      autoScroll = false;
      resumeBtn.style.display = "inline-block";
    } else {
      autoScroll = true;
      resumeBtn.style.display = "none";
    }
  });

  clearSearchBtn.onclick = () => {
  searchEl.innerHTML = "";
  };

  applyFilterBtn.onclick = () => {
  const pattern = filterInput.value.trim();
  sendCommand("Filter_by", [path], {pattern});
  };

  clearFilterBtn.onclick = () => {
    filterInput.value = "";
    sendCommand("remove_filter", [path]);
  };


  applyNotifyBtn.onclick = () => {
  const pattern = notifyInput.value.trim();
  sendCommand("Notify_when", [path], {pattern});
  };

  clearNotifyBtn.onclick = () => {
    notifyInput.value = "";
    sendCommand("remove_notification", [path]);
  };
  
  searchBtn.onclick = () => {
    const pattern = patternInput.value.trim();
    if (!pattern) return;

    sendCommand("search", [path], {
      pattern,
      regex: regexInput.checked
    });
  };

  resumeBtn.onclick = () => {
    tailEl.scrollTop = tailEl.scrollHeight;
    autoScroll = true;
    resumeBtn.style.display = "none";
  };



  panelDiv.querySelector(".start").onclick = () =>
    sendCommand("start_tailing", [path]);

  panelDiv.querySelector(".stop").onclick = () =>
    sendCommand("stop_tailing", [path]);

  panelDiv.querySelector(".clear").onclick = () => {
    tailEl.innerHTML = "";
    searchEl.innerHTML = "";
  };

  panelDiv.querySelector(".remove").onclick = () => {
    sendCommand("stop_tailing", [path]);
    panels.delete(path);
    panelDiv.remove();
  };

  panels.set(path, { tailEl, searchEl, panelDiv, autoScroll: () => autoScroll, resumeBtn });
}

// Update log appending logic for auto-scroll
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  const panel = panels.get(msg.path);
  if (!panel) return;

  if (msg.type === "log") {
    const tailEl = panel.tailEl;
    const div = document.createElement("div");
    div.textContent = msg.line;
    tailEl.appendChild(div);

    // Only scroll if user hasn't scrolled up
    if (panel.autoScroll()) {
      tailEl.scrollTop = tailEl.scrollHeight;
    }
  }

  if (msg.type === "log_batch") {
    const panel = panels.get(msg.path);
    if (!panel) return;

    const tailEl = panel.tailEl;
    const fragment = document.createDocumentFragment();

    msg.lines.forEach(line => {
      const div = document.createElement("div");
      div.textContent = line;
      fragment.appendChild(div);
    });

    tailEl.appendChild(fragment);

    // Jump instantly to bottom
    tailEl.scrollTop = tailEl.scrollHeight;
  }


  if (msg.type === "search_result") {
    const searchEl = panel.searchEl;
    const hasNormal = msg.lines.some(line => !line.includes("NOTIFICATION:"));
    if (hasNormal) searchEl.innerHTML = "";
    msg.lines.forEach(line => {
      const div = document.createElement("div");
      div.textContent = line;
      if (line.includes("NOTIFICATION:")) {
      div.classList.add("match-current"); // Use red highlight
      } else {
      div.classList.add("match");
      }
      searchEl.appendChild(div);
    });
  }
};

// Add paths button
document.getElementById("add-path").onclick = () => {
  const paths = pathInput.value.split("\n").map(p => p.trim()).filter(Boolean);
  paths.forEach(path => {
    createPanel(path);
    sendCommand("watch_paths", [path]);
  });
  pathInput.value = "";
};

// Stop all button
document.getElementById("stop-all").onclick = () => {
  panels.forEach((_, path) => sendCommand("stop_tailing", [path]));
};
</script>
</body>
</html>

